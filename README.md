# Maze #

## Содержание ##

1. [Алгоритм Эллера для генерации лабиринтов]()
   1. Алгоритм
   1. Реализация на C++

## Алгоритм Эллера для генерации лабиринтов ##

Для генерации лабиринта воспользуемся алгоритмом Эллера для построения односвязного лабиринта. Самое главное что нужно знать, что в односвязном лабиринте к точке выхода ведет всегда только один путь. 
Еще один момент, который нужно учитывать, что добраться до выхода можно используя "Правило руки":

> ...Один из методов состоит в том, чтобы в каждой узловой точке выбирать одно и то же направление. Например, можно всегда сворачивать на крайнюю правую ветвь. Если этот путь закончится тупиком, следует вернуться к узловой точке и выбрать следующую ветвь (если считать справа). Может оказаться, что в результате вы пройдете по каждой ветви дважды — по одному разу 
в каждом направлении, но в конце концов вы доберётесь до цели. На обратном пути можно либо продолжать выбирать крайние правые ветви в каждом узле (и в этом случае вы, вероятно, пройдёте по новым областям лабиринта), либо каждый раз сворачивать на крайнюю левую ветвь (и тогда вы в точности повторите первоначальный маршрут). Метод выбора одной и той же — правой или левой — ветви я называю соответственно правилом правой или левой руки... [[2]](http://ega-math.narod.ru/Nquant/Maze.htm)

Исходя из этого мы можем "запоминать" уже посещенные ячейки. И если, поблуждав в каком-то тупике, мы возвращаемся на правильный маршрут, мы можем исключить все дважды посещенные точки из списка с посещаемыми точками. Длинна этого списка, в конечном итоге, и будет являться длинной кратчайшего маршрута. Но эту часть мы подробней рассмотрим в пункте [2].
А теперь рассмотрим сам алгоритм.

### Алгоритм ###

[НУЖНО ПОДКОРРЕКТИРОВАТЬ АЛГОРИТМ В ЗАВИСИМОСТИ ОТ ПРАКТИЧЕСКОЙ РЕАЛИЗАЦИИ]()  
Примечание: предположим, что все левые ячейки лабиринта имеют левую стену, а все правые ячейки имеют правую стену.

1. Создайте первую строку лабиринта. Ниодна ячейка не будет принадлежать какому-либо множеству.
1. Присвоить каждой ячейке, которая не входит ни в одно множество, своё уникальное множество.
1. Создайте правые стены для ячеек, двигаясь слева направо, следующим образом:
   *  Случайным образом решите, добавлять стену или нет
       * Если текущая ячейка и ячейка справа являются членами одного и того же множества, всегда создавайте между ними стену (это предотвратит петли)
       * Если вы решите не добавлять стену, то объедините множества, к которым относятся текщая ячейка и ячейка справа
1. Создайте нижние стены, двигаясь слева направо:
   * Случайным образом решите, добавлять нижнюю стену или нет. *Важно:* Убедитесь, что каждая область имеет по крайней мере одну ячейку без нижней стены (это предотвратит создание изолированных областей)
       * Если ячейка является единственным членом своего множества, то не создавайте нижнюю стену
       * Если ячейка является единственным членом своего множества, которая не имеет нижней стены, то не создавайте нижнюю стену
1. Решите, продолжать добавлять строки или остановиться и завершить лабиринт
   * Если вы решите добавить еще одну строку:
       * скопируйте текущую строку
       * удалите в новой строку все правые стены
       * удалите ячейки с нижней стеной из их множества
       * удалите все нижние стены
       * продолжить с шага 2.
   * Если вы решили закончить лабиринт:
       * добавьте нижнюю стену каждой ячейке
       * перемещайтесь слева направо:
          * Если текущая ячейка и ячейка справа являются членами разных множеств, то:
             * удалить правую стену
             * объедините множества, к которым принадлежат текущая ячейка и ячейка справа
             * вывод итоговой строки

При первом прочтении ялгоритм может показаться слегка запутанным. Для лучшего понимания разберем пример:

**Шаг 1. Создайте первую строку лабиринта**
    
Это будет просто пустая строка:
```
 ___ ___ ___ ___ ___ ___ ___ ___
|                               |
```

**Шаг 2. Присвоить каждой ячейке, которая не входит ни в одно множество, своё уникальное множество.**

```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1   2   3   4   5   6   7   8 |
```

**Шаг 3. Создайте правые стены для ячеек, двигаясь слева направо**

```
 ___ ___ ___ ___ ___ ___ ___ ___
|(1   2)  3   4   5   6   7   8 |
```
Если мы решили не добавлять стену, объединим множества

```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1  (1   3)  4   5   6   7   8 |
```

```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1   1  (1   4)  5   6   7   8 |
```

```
    ...
 ___ ___ ___ ___ ___ ___ ___ ___
| 1   1   1 | 4   4 | 6   6   6 |
```

**Шаг 4. Создайте нижние стены, двигаясь слева направо**

Убедитесь, что каждая область имеет _по меньшей мере одну_ ячейку с нижним проходом (то есть без нижней стенки). Невыполнение этого требования приведет к изолированным областям.
```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1  _1_ _1_| 4  _4_| 6   6  _6_|
```
**Шаг 5.А Если вы решите добавить еще одну строку**

* скопируйте текущую строку
```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1  _1_ _1_| 4  _4_| 6   6  _6_|  <- строка закончена и емеет конечный вид
| 1  _1_ _1_| 4  _4_| 6   6  _6_|  <- скопированная строка, становиться текущей
```
* удалите в новой строку все правые стены
```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1  _1_ _1_| 4  _4_| 6   6  _6_|
| 1  _1_ _1_  4  _4_  6   6  _6_|
```
* удалите ячейки с нижней стеной из их множества
```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1  _1_ _1_| 4  _4_| 6   6  _6_|
| 1  ___ ___  4  ___  6   6  ___|
```
* удалите все нижние стены
```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1  _1_ _1_| 4  _4_| 6   6  _6_|
| 1           4       6   6     |
```
* продолжить с шага 2.

_Шаг 2.  Присвоить каждой ячейке, которая не входит ни в одно множество, своё уникальное множество._

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1   2   3   4   5   6   6   7 |
```
_Продолжая шаг 3. Добавьте правые стены_

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|(1 | 2)  3   4   5   6   6   7 |  <- Добавлена стена
```

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 |(2   3)  4   5   6   6   7 |  <- Не добавлена стена, множества 2 и 3 объединяются в одно
```

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2  (2   4)  5   6   6   7 |  <- Не добавлена стена, множества 2 и 4 объединяются в одно
```

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2   2  (2 | 5)  6   6   7 |  <- Добавлена стена
```

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2   2   2 |(5 | 6)  6   7 |  <- Добавлена стена
```

Следующие две ячейки являются членами одного множества, поэтому мы **должны** добавить стену. Невыполнение этого правила создает петли в нашем лабиринте.

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2   2   2 | 5 |(6 | 6)  7 |  <- ДОЛЖНЫ добавить стену
```

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2   2   2 | 5 | 6 |(6   7)|  <- Не добавлена стена, множества 6 и 7 объединяются в одно
```
_Продолжая шаг 4. Добавьте нижние стены_

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2   2   2 | 5 | 6 | 6   6 |
```
Помните: по крайней мере одна ячейка из каждого набора должна иметь нижний проход (т.е. не должна иметь нижнюю стенку).

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2  _2_ _2_| 5 |_6_| 6  _6_|
```
Вы можете добавить столько строк, сколько хотите.

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|_1_  1 | 3   3 | 7  _7_ _7_| 8 |
```

**Шаг 5.Б Если вы решили закончить лабиринт**

Последняя строка отличается от всех остальных двумя пунктами:
* Каждая ячейка имеет нижнюю стенку
* Все ячейки принадлежат одному и тому же множеству

Сделать каждую ячейку одного и того же набора просто. Просто удалите стены между ячейками, которые являются членами разных множеств, пока все ячейки не станут членами одного и того же множества. _Не удаляйте стену, если она разделяет две ячейки, которые являются членами одного и того же множества_

Начните с создания нормальной строки и добавьте нижнюю стенку в каждую ячейку
```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|___    |       |    ___ ___|   |
|_1_ _1_|_3_|_3_|_7_ _7_ _7_|_8_|
```
Завершающим шагом нам необходимо удалить все стены между ячейками, которые принадлежат разным множествам
```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|___    |       |    ___ ___|   |
|_1_ (1_|_3)|_3_|_7_ _7_ _7_|_8_|
```
```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|___    |       |    ___ ___|   |
|_1_ _1_ _1_|(1_|_7) _7_ _7_|_8_|
```
```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|___    |       |    ___ ___|   |
|_1_ _1_ _1_|_1_ _1_ _1_ (1_|_8)|
```
```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|___    |       |    ___ ___|   |
|_1_ _1_ _1_|_1_ _1_ _1_ _1_ _1_|
```
Теперь у нас должен получиться полноценный односвязный лабиринт. Нет никаких зацикленных областей (чтобы существовал только один путь между любыми двумя ячейками), и никакие области не являются замкнутыми (изолированными от остальной части лабиринта). Вы можете назначить любые две ячейки входом и выходом.

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|___    |       |    ___ ___|   |
|___ ___ ___|___ ___ ___ ___ ___|
```

Ещё одним достоинством этого алгоритма является то, что можно сгенерировать лабиринт любых размеров.

Так же в данном алгоритме возможно изменять внешний вид лабиринта, добавив смещение к генератору случайных чисел, чтобы вероятность появления правой стенки была большей (или меньшей), чем вероятность появления нижней стенки. Например, вы можете создавать лабиринты с более длинными горизонтальными проходами, реже создавая правые стенки и чаще - стены снизу. Но в данном контексте мы оставим алгоритм как есть и приступим к реализации этого алгоритма на C++.

### Реализация на C++ ###

Для простоты понимания, основной функционал алгоритма мы напишем на C++ без привязки к каким-либо графическим библиотекам или движкам, чтобы этот код можно было легко переиспользовать в любом удобном для вас виде. Графическую оболочку мы добавим делее в этой статье.

Для начала создадим класс, который будет реализовывать этот алгоритм. Результат (наш сгенерированный лабиринт) будем возвращать в виде двумерного динамического массива. Для удобства воспользуемся стандартным контейнером `std::vector`. Назовем наш класс `MazeGenerator`. Пусть он будет содержать только один статический метод `generate(unsigned width, unsigned height)`, который будет возвращать `shared_ptr` на матрицу с лабиринтом, представленную в виде `std::vector<std::vector<char>>`:

```C++
#pragma once
#include <vector>

class MazeGenerator
{
public:
	static std::shared_ptr<std::vector<std::vector<char>>> generate(unsigned width, unsigned height);

private:
	MazeGenerator() { }
};
```

Результатом этого метода будет вектор с векторами из символов (матрица из символов), где символом "` `"(пробел) является пустая ячейка, а символом "`#`"(решётка) - стена. Так как одна ячейка массива может быть либо пустой, либо стеной, то для генерации стен справа и снизу мы условимся что ячейка в понятии алгоритма - в массиве будет являться областью 2x2, чем мы упростим (? или усложним) себе задачу по отображению лабиринта в дальнейшем.

В связи с оговоренными условиями, сначала инициализируем размеры для векторов:

```C++
	static std::shared_ptr<std::vector<std::vector<char>>> generate(unsigned width, unsigned height)
	{
		// Проверим ограничения параметров на 0
		if ((width < 1) || (height < 1))
			return nullptr;

		auto top_limit = std::numeric_limits<unsigned>::max();
		// Проверим ограничения по максимальному допустимому размеру
		if (((top_limit - 1) / 2 <= width) || ((top_limit - 1) / 2 <= height))
			return nullptr;

		// Инициализируем размер конечной матрицы maze
		// Ячейки будут представлять из себя фрагменты 2x2 + 1 одно значение сверху и слева для стен
		unsigned output_height = height * 2 + 1;
		unsigned output_width = width * 2 + 1;
		// Инициализируем указатель на лабиринт и инициализируем его пустым значением
		auto maze = std::make_shared<std::vector<std::vector<char>>>(std::vector<std::vector<char>> {});
		// Зарезервируем размер лабиринта по высоте
		maze.get()->reserve(output_height);

		// ...

		// вернем указатель на полученный лабиринт
		return maze;
	}
```

## Библиографический список ##

1. [Eller's Algorithm](http://www.neocomputer.org/projects/eller.html)
2. [Как пройти через лабиринт не заблудившись. ДЖИРЛ УОЛКЕР](http://ega-math.narod.ru/Nquant/Maze.htm)