# Maze #

## Содержание ##

1. [Алгоритм Эллера для генерации лабиринтов]()
   1. Алгоритм
   1. Реализация на C++

## Алгоритм Эллера для генерации лабиринтов ##

Для генерации лабиринта воспользуемся алгоритмом Эллера для построения односвязного лабиринта. Самое главное что нужно знать, что в односвязном лабиринте к точке выхода ведет всегда только один путь. 
Еще один момент, который нужно учитывать, что добраться до выхода можно используя "Правило руки":

> ...Один из методов состоит в том, чтобы в каждой узловой точке выбирать одно и то же направление. Например, можно всегда сворачивать на крайнюю правую ветвь. Если этот путь закончится тупиком, следует вернуться к узловой точке и выбрать следующую ветвь (если считать справа). Может оказаться, что в результате вы пройдете по каждой ветви дважды — по одному разу 
в каждом направлении, но в конце концов вы доберётесь до цели. На обратном пути можно либо продолжать выбирать крайние правые ветви в каждом узле (и в этом случае вы, вероятно, пройдёте по новым областям лабиринта), либо каждый раз сворачивать на крайнюю левую ветвь (и тогда вы в точности повторите первоначальный маршрут). Метод выбора одной и той же — правой или левой — ветви я называю соответственно правилом правой или левой руки... [[2]](http://ega-math.narod.ru/Nquant/Maze.htm)

Исходя из этого мы можем "запоминать" уже посещенные ячейки. И если, поблуждав в каком-то тупике, мы возвращаемся на правильный маршрут, мы можем исключить все дважды посещенные точки из списка с посещаемыми точками. Длинна этого списка, в конечном итоге, и будет являться длинной кратчайшего маршрута. Но эту часть мы подробней рассмотрим в пункте [2].
А теперь рассмотрим сам алгоритм.

### Алгоритм ###

Примечание: предположим, что все левые ячейки лабиринта имеют левую стену, а все правые ячейки имеют правую стену.

1. Создайте первую строку лабиринта. Ниодна ячейка не будет принадлежать какому-либо множеству.
1. Присвоить каждой ячейке, которая не входит ни в одно множество, своё уникальное множество.
1. Создайте правые стены для ячеек, двигаясь слева направо, следующим образом:
   *  Случайным образом решите, добавлять стену или нет
       * Если текущая ячейка и ячейка справа являются членами одного и того же множества, всегда создавайте между ними стену (это предотвратит петли)
       * Если вы решите не добавлять стену, то объедините множества, к которым относятся текщая ячейка и ячейка справа
1. Создайте нижние стены, двигаясь слева направо:
   * Случайным образом решите, добавлять нижнюю стену или нет. *Важно:* Убедитесь, что каждая область имеет по крайней мере одну ячейку без нижней стены (это предотвратит создание изолированных областей)
       * Если ячейка является единственным членом своего множества, то не создавайте нижнюю стену
       * Если ячейка является единственным членом своего множества, которая не имеет нижней стены, то не создавайте нижнюю стену
1. Решите, продолжать добавлять строки или остановиться и завершить лабиринт
   * Если вы решите добавить еще одну строку:
       * скопируйте текущую строку
       * удалите в новой строку все правые стены
       * удалите ячейки с нижней стеной из их множества
       * удалите все нижние стены
       * продолжить с шага 2.
   * Если вы решили закончить лабиринт:
       * добавьте нижнюю стену каждой ячейке
       * перемещайтесь слева направо:
          * Если текущая ячейка и ячейка справа являются членами разных множеств, то:
             * удалить правую стену
             * объедините множества, к которым принадлежат текущая ячейка и ячейка справа
             * вывод итоговой строки

При первом прочтении ялгоритм может показаться слегка запутанным. Для лучшего понимания разберем пример:

**Шаг 1. Создайте первую строку лабиринта**
    
Это будет просто пустая строка:
```
 ___ ___ ___ ___ ___ ___ ___ ___
|                               |
```

**Шаг 2. Присвоить каждой ячейке, которая не входит ни в одно множество, своё уникальное множество.**

```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1   2   3   4   5   6   7   8 |
```

**Шаг 3. Создайте правые стены для ячеек, двигаясь слева направо**

```
 ___ ___ ___ ___ ___ ___ ___ ___
|(1   2)  3   4   5   6   7   8 |
```
Если мы решили не добавлять стену, объединим множества

```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1  (1   3)  4   5   6   7   8 |
```

```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1   1  (1   4)  5   6   7   8 |
```

```
    ...
 ___ ___ ___ ___ ___ ___ ___ ___
| 1   1   1 | 4   4 | 6   6   6 |
```

**Шаг 4. Создайте нижние стены, двигаясь слева направо**

Убедитесь, что каждая область имеет _по меньшей мере одну_ ячейку с нижним проходом (то есть без нижней стенки). Невыполнение этого требования приведет к изолированным областям.
```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1  _1_ _1_| 4  _4_| 6   6  _6_|
```
**Шаг 5.А Если вы решите добавить еще одну строку**

* скопируйте текущую строку
```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1  _1_ _1_| 4  _4_| 6   6  _6_|  <- строка закончена и емеет конечный вид
| 1  _1_ _1_| 4  _4_| 6   6  _6_|  <- скопированная строка, становиться текущей
```
* удалите в новой строку все правые стены
```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1  _1_ _1_| 4  _4_| 6   6  _6_|
| 1  _1_ _1_  4  _4_  6   6  _6_|
```
* удалите ячейки с нижней стеной из их множества
```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1  _1_ _1_| 4  _4_| 6   6  _6_|
| 1  ___ ___  4  ___  6   6  ___|
```
* удалите все нижние стены
```
 ___ ___ ___ ___ ___ ___ ___ ___
| 1  _1_ _1_| 4  _4_| 6   6  _6_|
| 1           4       6   6     |
```
* продолжить с шага 2.

_Шаг 2.  Присвоить каждой ячейке, которая не входит ни в одно множество, своё уникальное множество._

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1   2   3   4   5   6   6   7 |
```
_Продолжая шаг 3. Добавьте правые стены_

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|(1 | 2)  3   4   5   6   6   7 |  <- Добавлена стена
```

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 |(2   3)  4   5   6   6   7 |  <- Не добавлена стена, множества 2 и 3 объединяются в одно
```

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2  (2   4)  5   6   6   7 |  <- Не добавлена стена, множества 2 и 4 объединяются в одно
```

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2   2  (2 | 5)  6   6   7 |  <- Добавлена стена
```

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2   2   2 |(5 | 6)  6   7 |  <- Добавлена стена
```

Следующие две ячейки являются членами одного множества, поэтому мы **должны** добавить стену. Невыполнение этого правила создает петли в нашем лабиринте.

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2   2   2 | 5 |(6 | 6)  7 |  <- ДОЛЖНЫ добавить стену
```

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2   2   2 | 5 | 6 |(6   7)|  <- Не добавлена стена, множества 6 и 7 объединяются в одно
```
_Продолжая шаг 4. Добавьте нижние стены_

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2   2   2 | 5 | 6 | 6   6 |
```
Помните: по крайней мере одна ячейка из каждого набора должна иметь нижний проход (т.е. не должна иметь нижнюю стенку).

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
| 1 | 2  _2_ _2_| 5 |_6_| 6  _6_|
```
Вы можете добавить столько строк, сколько хотите.

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|_1_  1 | 3   3 | 7  _7_ _7_| 8 |
```

**Шаг 5.Б Если вы решили закончить лабиринт**

Последняя строка отличается от всех остальных двумя пунктами:
* Каждая ячейка имеет нижнюю стенку
* Все ячейки принадлежат одному и тому же множеству

Сделать каждую ячейку одного и того же набора просто. Просто удалите стены между ячейками, которые являются членами разных множеств, пока все ячейки не станут членами одного и того же множества. _Не удаляйте стену, если она разделяет две ячейки, которые являются членами одного и того же множества_

Начните с создания нормальной строки и добавьте нижнюю стенку в каждую ячейку
```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|___    |       |    ___ ___|   |
|_1_ _1_|_3_|_3_|_7_ _7_ _7_|_8_|
```
Завершающим шагом нам необходимо удалить все стены между ячейками, которые принадлежат разным множествам
```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|___    |       |    ___ ___|   |
|_1_ (1_|_3)|_3_|_7_ _7_ _7_|_8_|
```
```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|___    |       |    ___ ___|   |
|_1_ _1_ _1_|(1_|_7) _7_ _7_|_8_|
```
```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|___    |       |    ___ ___|   |
|_1_ _1_ _1_|_1_ _1_ _1_ (1_|_8)|
```
```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|___    |       |    ___ ___|   |
|_1_ _1_ _1_|_1_ _1_ _1_ _1_ _1_|
```
Теперь у нас должен получиться полноценный односвязный лабиринт. Нет никаких зацикленных областей (чтобы существовал только один путь между любыми двумя ячейками), и никакие области не являются замкнутыми (изолированными от остальной части лабиринта). Вы можете назначить любые две ячейки входом и выходом.

```
 ___ ___ ___ ___ ___ ___ ___ ___
|    ___ ___|    ___|        ___|
|   |    ___ ___|   |___|    ___|
|___    |       |    ___ ___|   |
|___ ___ ___|___ ___ ___ ___ ___|
```

Ещё одним достоинством этого алгоритма является то, что можно сгенерировать лабиринт любых размеров.

Так же в данном алгоритме возможно изменять внешний вид лабиринта, добавив смещение к генератору случайных чисел, чтобы вероятность появления правой стенки была большей (или меньшей), чем вероятность появления нижней стенки. Например, вы можете создавать лабиринты с более длинными горизонтальными проходами, реже создавая правые стенки и чаще - стены снизу. Но в данном контексте мы оставим алгоритм как есть и приступим к реализации этого алгоритма на C++.

### Реализация на C++ ###

Для простоты понимания, основной функционал алгоритма мы напишем на C++ без привязки к каким-либо графическим библиотекам или движкам, чтобы этот код можно было легко переиспользовать в любом удобном для вас виде. Графическую оболочку мы добавим делее в этой статье.

Для начала создадим класс, который будет реализовывать этот алгоритм. Результат (наш сгенерированный лабиринт) будем возвращать в виде двумерного динамического массива. Для удобства воспользуемся стандартным контейнером `std::vector`. Назовем наш класс `MazeGenerator`. Пусть он будет содержать только один статический метод `generate(unsigned width, unsigned height)`, который будет возвращать `shared_ptr` на матрицу с лабиринтом, представленную в виде `std::vector<std::vector<char>>`:

```C++
#pragma once
#include <vector>
#include <memory>

class MazeGenerator
{
public:
	static std::shared_ptr<std::vector<std::vector<char>>> generate(unsigned width, unsigned height);

private:
	MazeGenerator() { }
};
```

Результатом этого метода будет вектор с векторами из символов (матрица из символов), где символом "` `"(пробел) является пустая ячейка, а символом "`#`"(решётка) - стена. Так как одна ячейка массива может быть либо пустой, либо стеной, то для генерации стен справа и снизу мы условимся что ячейка в понятии алгоритма - в массиве будет являться областью 2x2, чем мы упростим (? или усложним) себе задачу по отображению лабиринта в дальнейшем.

В связи с оговоренными условиями, сначала инициализируем размеры для векторов:

```C++
static std::shared_ptr<std::vector<std::vector<char>>> generate(unsigned width, unsigned height)
{
	// Проверим ограничения параметров на 0
	if ((width < 1) || (height < 1))
		return nullptr;

	auto top_limit = std::numeric_limits<unsigned>::max();
	// Проверим ограничения по максимальному допустимому размеру
	if (((top_limit - 1) / 2 <= width) || ((top_limit - 1) / 2 <= height))
		return nullptr;

	// Инициализируем размер конечной матрицы maze
	// Ячейки будут представлять из себя фрагменты 2x2 + 1 одно значение сверху и слева для стен
	unsigned output_height = height * 2 + 1;
	unsigned output_width = width * 2 + 1;
	// Инициализируем указатель на лабиринт
	auto maze = std::make_shared<std::vector<std::vector<char>>>();
	// Зарезервируем размер лабиринта по высоте
	maze.get()->reserve(output_height);

	// ...

	// вернем указатель на полученный лабиринт
	return maze;
}
```

После зарезервированого объема, инициализируем наш лабиринт начальными данными. Ограничим лабиринт по периметру стенами. Всю область лабиринта, за исключением верхней строки со стеной и левого столбца со стеной можно условно разделить на области 2x2, где левая верхняя ячейка будет являться самой ячейкой в лабиринте, аналогично ячейки из алгоритма. Правая верхняя ячейка в этой области - место для стены (или прохода) справа, а левая нижняя - место для стены (или прохода) снизу. Изначально кроме стен по периметру - у каждой ячейки справа и снизу не будет стен. Но в каждой области 2x2 справа снизу установим стену, так как это не функциональная область, которая не рассматривается в алгоритме. У нас она всегда будет стеной или "опорой".

```C++
// Инициализируем построчно пустой лабиринт со стенами по периметру и "опорами" (стенами) в нижнем правом углу ячеек 2x2
// #######
// #     #
// # # # #
// #     #
// #######
for (unsigned i = 0; i < output_height; ++i)
{
	std::vector<char> row;
	row.reserve(output_width);
	for (unsigned j = 0; j < output_width; ++j)
		// Если этот элемент в строке является ячейкой в левом верхнем угле области 2x2 - то это пустая ячейка в лабиринте
		if ((i % 2 == 1) && (j % 2 == 1))
			row.push_back(' ');
		else
			// Если это область для стены справа или область для стены снизу - то инициализируем этот элемент пустой ячейкой в лабиринте
			if (((i % 2 == 1) && (j % 2 == 0) && (j != 0) && (j != output_width - 1)) ||
				((j % 2 == 1) && (i % 2 == 0) && (i != 0) && (i != output_height - 1)))
				row.push_back(' ');
			else 
				// Во всех остальных случаях устанавливаем стену
				row.push_back('#');
	maze.get()->push_back(std::move(row));
}
```

Теперь нам надо организовать цикл, к котором будут реализованы все шаги алгоритма. Т.к. высота лабиринта передается параметром, то достаточно использовать цикл `for`:

```C++
//1. Создайте первую строку лабиринта.Ниодна ячейка не будет принадлежать какому - либо множеству.
// Инициализируем вспомогательную строку, которая будет содержать в себе принадлежность ко множеству для ячейки из алгоритма
std::vector<unsigned> row_set;
row_set.reserve(width);
// 0 - будет означать, что ячейка не принадлежит никакому множеству
for (unsigned i = 0; i < width; ++i)
	row_set.push_back(0);
// И инициализируем счетчик для множеств
unsigned set = 1;
// Инициализируем генератор случайных чисел
std::random_device rd;
std::mt19937 mt(rd());
// от 0 до 2 (2 не входит) и после привидения к int будет либо 0 - где стены нет, либо 1 - стену решили установить
uniform_int_distribution<int> dist(0, 2);
// Организуем цикл алгоритма Эллера
for (unsigned i = 0; i < height; ++i)
{			
	//2. Присвоить каждой ячейке, которая не входит ни в одно множество, своё уникальное множество.
	//3. Создайте правые стены для ячеек, двигаясь слева направо, следующим образом :
	//	* Случайным образом решите, добавлять стену или нет
	//		* Если текущая ячейка и ячейка справа являются членами одного и того же множества, всегда создавайте между ними стену(это предотвратит петли)
	//		* Если вы решите не добавлять стену, то объедините множества, к которым относятся текщая ячейка и ячейка справа
	//4. Создайте нижние стены, двигаясь слева направо :
	//	* Случайным образом решите, добавлять нижнюю стену или нет. *Важно : *Убедитесь, что каждая область имеет по крайней мере одну ячейку без нижней стены(это предотвратит создание изолированных областей)
	//		* Если ячейка является единственным членом своего множества, то не создавайте нижнюю стену
	//		* Если ячейка является единственным членом своего множества, которая не имеет нижней стены, то не создавайте нижнюю стену
	//5. Решите, продолжать добавлять строки или остановиться и завершить лабиринт
	//	* Если вы решите добавить еще одну строку :
	//		* скопируйте текущую строку
	//		* удалите в новой строку все правые стены
	//		* удалите ячейки с нижней стеной из их множества
	//		* удалите все нижние стены
	//		* продолжить с шага 2.
}

//	* Если вы решили закончить лабиринт :
//		*добавьте нижнюю стену каждой ячейке
//		* перемещайтесь слева направо :
//			*Если текущая ячейка и ячейка справа являются членами разных множеств, то :
//			*удалить правую стену
//			* объедините множества, к которым принадлежат текущая ячейка и ячейка справа
//			* вывод итоговой строки

```

Теперь по шагам приступим к реализации:

```C++
//2. Присвоить каждой ячейке, которая не входит ни в одно множество, своё уникальное множество.
for (unsigned j = 0; j < width; ++j)
	if (row_set[j] == 0)
		row_set[j] = set++;
```

На 3ем шаге алгоритма выберем, с помощью генератора случайных чисел, будем мы добавлять стену или нет. Выполняя все условия шага 3 мы получим:

```C++
//3. Создайте правые стены для ячеек, двигаясь слева направо, следующим образом :
for (unsigned j = 0; j < width - 1; ++j)
{
	//	* Случайным образом решите, добавлять стену или нет
	const auto right_wall = dist(mt);
	//		* Если текущая ячейка и ячейка справа являются членами одного и того же множества, всегда создавайте между ними стену(это предотвратит петли)
	if ((right_wall == 1) || (row_set[j] == row_set[j + 1]))
		maze.get()->at(i * 2 + 1/*верхний ряд в i-ом ряду ячеек 2x2*/).at(j * 2 + 2/*Правый столбец в (i;j) ячейке 2x2*/) = '#';/*Создаем стену*/				
	else
	{
		//		* Если вы решите не добавлять стену, то объедините множества, к которым относятся текщая ячейка и ячейка справа
		const auto changing_set = row_set[j + 1];
		for (unsigned l = 0; l < width; ++l)
			if (row_set[l] == changing_set)
				row_set[l] = row_set[j];
	}
}
```

Аналогичным образом строим нижние стены:

```C++
//4. Создайте нижние стены, двигаясь слева направо :
for (unsigned j = 0; j < width; ++j)
{				
	//	* Случайным образом решите, добавлять нижнюю стену или нет. 
	const auto bottom_wall = dist(mt);
	//		* Если ячейка является единственным членом своего множества, то не создавайте нижнюю стену
	unsigned int count_current_set = 0;
	for (unsigned l = 0; l < width; ++l)
		// считаем количество ячеек текущего множества
		if (row_set[j] == row_set[l])
			count_current_set++;
	//		* Если ячейка является единственным членом своего множества, которая не имеет нижней стены, то не создавайте нижнюю стену
	if ((bottom_wall == 1) && (count_current_set != 1))
		maze.get()->at(i * 2 + 2).at(j * 2 + 1) = '#';
}
```

Не забудем и про предупреждение в алгоритме. Необходимо убедиться, что хотя бы одна ячейка из множества должна быть без нижней стены, чтобы предотвратить создание изолированных областей:

```C++
//*Важно : *Убедитесь, что каждая область имеет по крайней мере одну ячейку без нижней стены(это предотвратит создание изолированных областей)
for (unsigned j = 0; j < width; ++j) {
	unsigned count_hole = 0;
	for (unsigned l = 0; l < width; ++l)
		if ((row_set[l] == row_set[j]) && (maze.get()->at(i * 2 + 2).at(l * 2 + 1) == ' '))
			count_hole++;
	if (count_hole == 0)
		maze.get()->at(i * 2 + 2).at(j * 2 + 1) = ' ';
}
```

На 5ом шаге, если мы еще не дошли до последней строки лабиринта, то производим необходимые манипуляции с вектором множеств:

```C++
//5. Решите, продолжать добавлять строки или остановиться и завершить лабиринт
//	* Если вы решите добавить еще одну строку :
if (i != height - 1)
{
	//		* скопируйте текущую строку
	//		* удалите в новой строку все правые стены
	/// Правые стенки в инициализированном массиве у нас уже отсутствуют в каждой новой строке
	//		* удалите ячейки с нижней стеной из их множества
	for (unsigned j = 0; j < width; ++j)
		if (maze.get()->at(i * 2 + 2/* Проверим надичие нижней стены у текущего ряда*/).at(j * 2 + 1) == '#')
			// Если стенка есть, то удаляем ячейку из множества
			row_set[j] = 0;
	//		* удалите все нижние стены
	/// Нижние стены в каждом новом ряду ячеек отсутствуют (заложено при инициализации)
}
//		* продолжить с шага 2.
```

Цикл заканчивается и остался последний шаг 5.Б по завершению лабиринта. На данном этапе структура метода примерно следующая:

```C++
static std::shared_ptr<std::vector<std::vector<char>>> generate(unsigned width, unsigned height)
{
	// Проверки
	// ...

	// Инициализация
	// ...
	
	//1. Создайте первую строку лабиринта.Ниодна ячейка не будет принадлежать какому - либо множеству.
	// ... реализация шага 1 ...

	// Организуем цикл алгоритма Эллера
	for (unsigned i = 0; i < height; ++i)
	{			
		//2. Присвоить каждой ячейке, которая не входит ни в одно множество, своё уникальное множество.
		// ... реализация шага 2 ...

		//3. Создайте правые стены для ячеек, двигаясь слева направо, следующим образом :
		// ... реализация шага 3 ...

		//4. Создайте нижние стены, двигаясь слева направо :
		// ... реализация шага 4 ...

		//5. Решите, продолжать добавлять строки или остановиться и завершить лабиринт
		// ... реализация шага 5.A
		//		* продолжить с шага 2.
	}

	// TODO: Осталось добавить реализацию завершения лабиринта.

	//	* Если вы решили закончить лабиринт :
	//		*добавьте нижнюю стену каждой ячейке
	//		* перемещайтесь слева направо :
	//			*Если текущая ячейка и ячейка справа являются членами разных множеств, то :
	//			*удалить правую стену
	//			* объедините множества, к которым принадлежат текущая ячейка и ячейка справа
	//			* вывод итоговой строки

	// вернем указатель на полученный лабиринт
	return maze;
}
```



## Используемая литература ##

1. [Eller's Algorithm](http://www.neocomputer.org/projects/eller.html)
2. [Как пройти через лабиринт не заблудившись. ДЖИРЛ УОЛКЕР](http://ega-math.narod.ru/Nquant/Maze.htm)